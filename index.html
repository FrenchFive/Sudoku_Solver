<!DOCTYPE html>
<html>
<head>
    <title>Sudoku Solver</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Enter Sudoku</h1>
        <form method="POST" action="/" onsubmit="showLoading(event);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <table>
                <!-- Python script dynamically fills the rows and cells -->
                {table_rows}
            </table>
            <input type="submit" value="Solve" id="solveButton">
            <button type="button" id="clearButton">Clear</button>
            <div id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>Solving... Please wait.</p>
            </div>
        </form>
        <!-- Solution will be shown directly in the grid -->
    </div>
    <script>
        window.onload = function() {
            console.log('JavaScript is running');
            var originalGrid = [];
            var progressTimer = null;
            var POLL_INTERVAL = 100; // milliseconds
    
            window.showLoading = function(event) {
                event.preventDefault(); // Prevent the default form submission
                console.log('showLoading called');
                document.getElementById('solveButton').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
    
                // Capture the original grid values
                originalGrid = [];
                for (var i = 0; i < 9; i++) {
                    originalGrid[i] = [];
                    for (var j = 0; j < 9; j++) {
                        var input = document.querySelector('input[name="cell_' + i + '_' + j + '"]');
                        originalGrid[i][j] = parseInt(input.value) || 0;
                    }
                }

                // Start checking for solution and progress
                checkSolution();
                progressTimer = setInterval(fetchProgress, POLL_INTERVAL);
    
                // Serialize the form data
                var form = document.querySelector('form');
                var formData = new FormData(form);
                var urlEncodedData = new URLSearchParams();
    
                for (var pair of formData.entries()) {
                    urlEncodedData.append(pair[0], pair[1]);
                }
    
                fetch('/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: urlEncodedData.toString()
                })
                .then(function(response) {
                    console.log('Form submitted via AJAX');
                })
                .catch(function(error) {
                    console.error('Error submitting form:', error);
                });
            };

            document.getElementById('clearButton').addEventListener('click', function(e) {
                e.preventDefault();
                fetch('/clear', {method: 'POST'})
                    .then(function() {
                        location.reload();
                    })
                    .catch(function(error) {
                        console.error('Error clearing grid:', error);
                    });
            });

            function checkSolution() {
                fetch('/solution')
                    .then(function(response) {
                        if (response.status === 200) {
                            return response.json();
                        } else {
                            setTimeout(checkSolution, POLL_INTERVAL);
                            return null;
                        }
                    })
                    .then(function(data) {
                        if (data) {
                            displaySolution(data.solution, data.original);
                        }
                    })
                    .catch(function(error) {
                        setTimeout(checkSolution, POLL_INTERVAL);
                    });
            }

            function fetchProgress() {
                fetch('/progress')
                    .then(function(response) {
                        if (response.status === 200) {
                            return response.json();
                        }
                        return null;
                    })
                    .then(function(data) {
                        if (data) {
                            displayProgress(data.grid);
                        }
                    })
                    .catch(function(error) {
                        // Ignore errors and try again on next interval
                    });
            }

            function displayProgress(grid) {
                for (var i = 0; i < 9; i++) {
                    for (var j = 0; j < 9; j++) {
                        var input = document.querySelector('input[name="cell_' + i + '_' + j + '"]');
                        if (input && originalGrid.length) {
                            input.value = grid[i][j] === 0 ? '' : grid[i][j];
                            if (originalGrid[i][j] === 0) {
                                input.parentElement.classList.add('solver-progress');
                            }
                        }
                    }
                }
            }

            function displaySolution(solution, original) {
                console.log('Displaying solution...');
                document.getElementById('loading').style.display = 'none';
                if (progressTimer) {
                    clearInterval(progressTimer);
                }
                var cells = document.querySelectorAll('td');
                cells.forEach(function(td) {
                    td.classList.remove('solver-progress');
                });

                for (var i = 0; i < 9; i++) {
                    for (var j = 0; j < 9; j++) {
                        var input = document.querySelector('input[name="cell_' + i + '_' + j + '"]');
                        if (input) {
                            input.value = solution[i][j];
                            input.disabled = true;
                            if (original[i][j] === 0) {
                                input.parentElement.classList.add('solver-filled');
                            }
                        }
                    }
                }
            }

            document.addEventListener("keydown", function(e) {
                var activeElement = document.activeElement;

                // Check if the active element is an input
                if (activeElement.tagName === "INPUT" && activeElement.type === "text") {
                    if (!isNaN(e.key) && e.key !== " " && e.key !== "0") {
                        // Replace the content of the input with the pressed key (non-zero numbers)
                        activeElement.value = e.key;
                        e.preventDefault(); // Prevent default behavior
                    } else if (e.key === "0" || e.key === "Backspace" || e.key === "Delete") {
                        // Clear the input when "0", "Backspace", or "Delete" is pressed
                        activeElement.value = "";
                        e.preventDefault(); // Prevent default behavior
                    }

                    // Handle arrow key navigation
                    var currentCell = activeElement.parentElement;
                    var row = currentCell.parentElement;
                    var nextInput = null;

                    switch (e.key) {
                        case "ArrowUp":
                            if (row.previousElementSibling && row.previousElementSibling.children[currentCell.cellIndex]) {
                                nextInput = row.previousElementSibling.children[currentCell.cellIndex].querySelector("input");
                            }
                            break;
                        case "ArrowDown":
                            if (row.nextElementSibling && row.nextElementSibling.children[currentCell.cellIndex]) {
                                nextInput = row.nextElementSibling.children[currentCell.cellIndex].querySelector("input");
                            }
                            break;
                        case "ArrowLeft":
                            if (currentCell.previousElementSibling) {
                                nextInput = currentCell.previousElementSibling.querySelector("input");
                            }
                            break;
                        case "ArrowRight":
                            if (currentCell.nextElementSibling) {
                                nextInput = currentCell.nextElementSibling.querySelector("input");
                            }
                            break;
                    }

                    // Move focus to the next input if available
                    if (nextInput) {
                        nextInput.focus();
                        e.preventDefault();
                    }
                }
            });
        };
    </script>
</body>
</html>
