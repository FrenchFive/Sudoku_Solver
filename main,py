import os
import time
import multiprocessing
from multiprocessing import Manager
import threading
import http.server
import urllib.parse
import json

def run_server(shared_state):
    import http.server
    import os
    import threading
    import json
    import urllib.parse

    script_dir = os.path.dirname(os.path.abspath(__file__))

    class SudokuHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            if self.path == '/' or self.path == '/index.html':
                # Read index.html
                index_path = os.path.join(script_dir, 'index.html')
                try:
                    with open(index_path, 'r', encoding='utf-8') as f:
                        html = f.read()
                except FileNotFoundError:
                    self.send_error(404, "File not found.")
                    return
                # Generate table rows
                table_rows = ''
                grid = shared_state['grid']
                for i in range(9):
                    table_rows += '<tr>'
                    for j in range(9):
                        value = grid[i][j] if grid[i][j] != 0 else ''
                        table_rows += '<td><input type="text" name="cell_{}_{}" value="{}" maxlength="1" autocomplete="off"></td>'.format(i, j, value)
                    table_rows += '</tr>'
                # Replace placeholder
                html = html.replace('{table_rows}', table_rows)
                # Send response
                self.send_response(200)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                self.wfile.write(html.encode('utf-8'))
            elif self.path == '/solution':
                if shared_state.get('solution', None):
                    # Send solution as JSON
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    response = {
                        'solution': shared_state['solution'],
                        'original': shared_state['grid']
                    }
                    self.wfile.write(json.dumps(response).encode('utf-8'))
                else:
                    # Solution not ready
                    self.send_response(204)  # No Content
                    self.end_headers()
            elif self.path == '/progress':
                progress = shared_state.get('progress', None)
                if progress is not None:
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({'grid': progress}).encode('utf-8'))
                else:
                    self.send_response(204)
                    self.end_headers()
            else:
                # Serve static files
                return http.server.SimpleHTTPRequestHandler.do_GET(self)

        def do_POST(self):
            # Process form data
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            # Parse form data
            parsed_data = urllib.parse.parse_qs(post_data.decode('utf-8'))
            # Update grid
            grid = [[0]*9 for _ in range(9)]
            for i in range(9):
                for j in range(9):
                    cell_name = 'cell_{}_{}'.format(i, j)
                    value = parsed_data.get(cell_name, [''])[0]
                    try:
                        num = int(value)
                        if 1 <= num <= 9:
                            grid[i][j] = num
                        else:
                            grid[i][j] = 0
                    except ValueError:
                        grid[i][j] = 0
            # Save grid to shared_state
            shared_state['grid'] = grid
            shared_state['input_received'] = True
            # Send response
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            # Read index.html
            index_path = os.path.join(script_dir, 'index.html')
            try:
                with open(index_path, 'r', encoding='utf-8') as f:
                    html = f.read()
            except FileNotFoundError:
                    self.send_error(404, "File not found.")
                    return
            # Generate table rows
            table_rows = ''
            for i in range(9):
                table_rows += '<tr>'
                for j in range(9):
                    value = grid[i][j] if grid[i][j] != 0 else ''
                    table_rows += '<td><input type="text" name="cell_{}_{}" value="{}" maxlength="1" autocomplete="off"></td>'.format(i, j, value)
                table_rows += '</tr>'
            # Replace placeholder
            html = html.replace('{table_rows}', table_rows)
            # Send response
            self.wfile.write(html.encode('utf-8'))

    # Try to find an available port
    for port in range(8000, 9000):
        try:
            server_address = ('', port)
            httpd = http.server.HTTPServer(server_address, SudokuHTTPRequestHandler)
            shared_state['port'] = port
            break
        except OSError as e:
            if e.errno == 98:  # Address already in use
                continue
            else:
                raise
    else:
        print("No available port found between 8000 and 9000.")
        shared_state['server_failed'] = True
        return

    # Run the server
    httpd.serve_forever()

def print_grid(grid):
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print("-"*21)
        for j in range(9):
            if j % 3 == 0 and j != 0:
                print("| ", end='')
            print(str(grid[i][j]) if grid[i][j] != 0 else '.', end=' ')
        print()

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def find_empty_cell(grid):
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                return i, j
    return None

def is_valid(grid, row, col, num):
    # Check row
    if num in grid[row]:
        return False
    # Check column
    if num in (grid[i][col] for i in range(9)):
        return False
    # Check box
    start_row = row - row % 3
    start_col = col - col % 3
    for i in range(3):
        for j in range(3):
            if grid[start_row + i][start_col + j] == num:
                return False
    return True

def get_possible_numbers(grid, row, col):
    numbers = set(range(1, 10))
    numbers -= set(grid[row])  # Remove numbers present in the row
    numbers -= set(grid[i][col] for i in range(9))  # Remove numbers present in the column
    start_row = row - row % 3
    start_col = col - col % 3
    # Remove numbers present in the 3x3 box
    numbers -= set(
        grid[start_row + i][start_col + j]
        for i in range(3) for j in range(3)
    )
    return numbers

def count_constraints(grid, row, col, num):
    count = 0
    for i in range(9):
        if grid[row][i] == 0:
            count += 1
        if grid[i][col] == 0:
            count += 1
    start_row = row - row % 3
    start_col = col - col % 3
    for i in range(3):
        for j in range(3):
            if grid[start_row + i][start_col + j] == 0:
                count += 1
    return count

def solve_sudoku(grid, queue=None, progress=None, worker_id=None, stop_event=None, stats=None, shared_state=None):
    if stop_event and stop_event.is_set():
        return False
    empty_cell = find_empty_cell(grid)
    if not empty_cell:
        return True
    row, col = empty_cell
    possible_numbers = get_possible_numbers(grid, row, col)
    if not possible_numbers:
        if stats is not None:
            stats['backtracks'] += 1
        return False
    possible_numbers = sorted(possible_numbers, key=lambda num: count_constraints(grid, row, col, num))
    for num in possible_numbers:
        if stop_event and stop_event.is_set():
            return False
        if is_valid(grid, row, col, num):
            grid[row][col] = num
            if stats is not None:
                stats['attempts'] += 1
            if progress is not None:
                progress['grid'] = [row[:] for row in grid]
            if shared_state is not None:
                shared_state['progress'] = [row[:] for row in grid]
            if solve_sudoku(grid, queue, progress, worker_id, stop_event, stats, shared_state):
                if queue and queue.empty():
                    queue.put([row[:] for row in grid])
                return True
            grid[row][col] = 0
            if stats is not None:
                stats['backtracks'] += 1
    return False

def worker(grid, queue, progress, worker_id, stop_event, stats, initial_cell, shared_state=None):
    grid_copy = [row[:] for row in grid]
    row, col, possible_numbers = initial_cell
    possible_numbers = sorted(possible_numbers, key=lambda num: count_constraints(grid_copy, row, col, num))
    for num in possible_numbers:
        if stop_event.is_set():
            break
        if is_valid(grid_copy, row, col, num):
            grid_copy[row][col] = num
            if stats is not None:
                stats['attempts'] += 1
            if progress is not None:
                progress['grid'] = [row[:] for row in grid_copy]
            if shared_state is not None:
                shared_state['progress'] = [row[:] for row in grid_copy]
            if solve_sudoku(grid_copy, queue, progress, worker_id, stop_event, stats, shared_state):
                stop_event.set()
                if queue.empty():
                    queue.put([row[:] for row in grid_copy])
                break
            grid_copy[row][col] = 0
            if stats is not None:
                stats['backtracks'] += 1

def display_progress(progress, stop_event):
    while not stop_event.is_set():
        clear_screen()
        print("Solving Sudoku...")
        if 'grid' in progress:
            print_grid(progress['grid'])
        else:
            print("Initializing...")
        time.sleep(0.5)
    clear_screen()
    if 'grid' in progress:
        print("Solved Sudoku:")
        print_grid(progress['grid'])
    else:
        print("No solution found.")

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    save_file = os.path.join(script_dir, "sudoku_save.txt")

    manager = multiprocessing.Manager()
    shared_state = manager.dict()
    shared_state['grid'] = [[0]*9 for _ in range(9)]
    shared_state['solution'] = None
    shared_state['stats'] = {'attempts': 0, 'backtracks': 0}
    shared_state['progress'] = [[0]*9 for _ in range(9)]
    shared_state['input_received'] = False
    shared_state['server_failed'] = False
    shared_state['port'] = None

    # Try to load saved grid
    if os.path.exists(save_file):
        with open(save_file, 'r') as f:
            lines = f.readlines()
            if len(lines) == 9:
                grid = [[0]*9 for _ in range(9)]
                for i in range(9):
                    row_values = list(map(int, lines[i].strip().split()))
                    if len(row_values) == 9:
                        grid[i] = row_values
                shared_state['grid'] = grid

    # Start the server process
    server_process = multiprocessing.Process(target=run_server, args=(shared_state,))
    server_process.start()

    # Wait for the server to set the port or fail
    while shared_state['port'] is None and not shared_state['server_failed']:
        time.sleep(0.1)

    if shared_state['server_failed']:
        print("Failed to start the server. Exiting.")
        server_process.terminate()
        server_process.join()
        return

    port = shared_state['port']
    print(f"Please open your web browser and go to http://localhost:{port} to enter the Sudoku.")

    # Wait until input is received
    while not shared_state.get('input_received', False):
        time.sleep(0.1)

    grid = shared_state['grid']
    # Save grid to file
    with open(save_file, 'w') as f:
        for row in grid:
            f.write(' '.join(map(str, row)) + '\n')

    clear_screen()
    print("Solving the sudoku...")
    time.sleep(1)
    start_time = time.time()

    manager = Manager()
    queue = manager.Queue()
    progress = manager.dict()
    progress['grid'] = [row[:] for row in grid]
    shared_state['progress'] = [row[:] for row in grid]
    stats = manager.dict()
    stats['attempts'] = 0
    stats['backtracks'] = 0
    stop_event = multiprocessing.Event()

    # Preprocessing: Find cells with the least possibilities
    empty_cells = []
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                possible_numbers = get_possible_numbers(grid, i, j)
                empty_cells.append((i, j, possible_numbers))
    empty_cells.sort(key=lambda x: len(x[2]))
    if not empty_cells:
        print("Sudoku already solved!")
        return

    num_workers = min(9, multiprocessing.cpu_count(), len(empty_cells))
    processes = []

    # Start display thread
    display_thread = threading.Thread(target=display_progress, args=(progress, stop_event))
    display_thread.start()

    # Start worker processes
    for worker_id in range(num_workers):
        initial_cell = empty_cells[worker_id]
        p = multiprocessing.Process(target=worker, args=(
            grid, queue, progress, worker_id, stop_event, stats, initial_cell, shared_state))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

    stop_event.set()
    display_thread.join()

    end_time = time.time()
    elapsed_time = end_time - start_time

    clear_screen()
    if not queue.empty():
        solved_grid = queue.get()
        print("Sudoku solved:")
        print_grid(solved_grid)
        # Update shared_state with the solution
        shared_state['solution'] = solved_grid
        shared_state['stats'] = {
            'attempts': stats['attempts'],
            'backtracks': stats['backtracks']
        }
        shared_state['progress'] = solved_grid
    else:
        print("No solution exists.")

    # Display statistics
    print("\nStatistics:")
    print(f"Time taken: {elapsed_time:.2f} seconds")
    print(f"Total attempts: {stats['attempts']}")
    print(f"Total backtracks: {stats['backtracks']}")
    if stats['attempts'] > 0:
        print(f"Backtrack ratio: {stats['backtracks']/stats['attempts']:.2f}")
    else:
        print("No attempts were made.")

    # Keep the server running to serve the solution
    print("Solution ready. You can view it in your browser.")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        pass
    finally:
        server_process.terminate()
        server_process.join()
        print("Server stopped.")

if __name__ == "__main__":
    main()
