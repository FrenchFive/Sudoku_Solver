import os
import time
import multiprocessing
from multiprocessing import Manager
import threading

def input_grid():
    grid = []
    print("Enter the sudoku grid, row by row, using zeros for empty cells.")
    print("Separate numbers with spaces.")
    for i in range(9):
        while True:
            try:
                row = input(f"Row {i+1}: ")
                row_values = list(map(int, row.strip().split()))
                if len(row_values) != 9:
                    print("Please enter exactly 9 numbers.")
                    continue
                grid.append(row_values)
                break
            except ValueError:
                print("Invalid input. Please enter numbers separated by spaces.")
    return grid

def print_grid(grid):
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print("-"*21)
        for j in range(9):
            if j % 3 == 0 and j != 0:
                print("| ", end='')
            print(str(grid[i][j]) if grid[i][j] != 0 else '.', end=' ')
        print()
        
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def find_empty_cell(grid):
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                return i, j
    return None

def is_valid(grid, row, col, num):
    if num in grid[row]:
        return False
    if num in (grid[i][col] for i in range(9)):
        return False
    start_row = row - row % 3
    start_col = col - col % 3
    if num in (
        grid[start_row + i][start_col + j]
        for i in range(3) for j in range(3)
    ):
        return False
    return True

def get_possible_numbers(grid, row, col):
    numbers = set(range(1, 10))
    numbers -= set(grid[row])
    numbers -= set(grid[i][col] for i in range(9))
    start_row = row - row % 3
    start_col = col - col % 3
    numbers -= set(
        grid[start_row + i][start_col + j]
        for i in range(3) for j in range(3)
    )
    return numbers

def count_constraints(grid, row, col, num):
    count = 0
    for i in range(9):
        if grid[row][i] == 0:
            count += 1
        if grid[i][col] == 0:
            count += 1
    start_row = row - row % 3
    start_col = col - col % 3
    for i in range(3):
        for j in range(3):
            if grid[start_row + i][start_col + j] == 0:
                count += 1
    return count

def solve_sudoku(grid, queue=None, progress=None, worker_id=None, stop_event=None, stats=None):
    if stop_event.is_set():
        return False
    empty_cell = find_empty_cell(grid)
    if not empty_cell:
        return True
    row, col = empty_cell
    possible_numbers = get_possible_numbers(grid, row, col)
    if not possible_numbers:
        if stats is not None:
            stats['backtracks'] += 1
        return False
    possible_numbers = sorted(possible_numbers, key=lambda num: count_constraints(grid, row, col, num))
    for num in possible_numbers:
        if stop_event.is_set():
            return False
        if is_valid(grid, row, col, num):
            grid[row][col] = num
            if stats is not None:
                stats['attempts'] += 1
            if progress is not None:
                progress['grid'] = [row[:] for row in grid]
            if solve_sudoku(grid, queue, progress, worker_id, stop_event, stats):
                if queue and queue.empty():
                    queue.put(grid)
                return True
            grid[row][col] = 0
            if stats is not None:
                stats['backtracks'] += 1
    return False

def worker(grid, queue, progress, worker_id, stop_event, stats, initial_cell):
    grid_copy = [row[:] for row in grid]
    row, col, possible_numbers = initial_cell
    possible_numbers = sorted(possible_numbers, key=lambda num: count_constraints(grid_copy, row, col, num))
    for num in possible_numbers:
        if stop_event.is_set():
            break
        if is_valid(grid_copy, row, col, num):
            grid_copy[row][col] = num
            if stats is not None:
                stats['attempts'] += 1
            if progress is not None:
                progress['grid'] = [row[:] for row in grid_copy]
            if solve_sudoku(grid_copy, queue, progress, worker_id, stop_event, stats):
                stop_event.set()
                if queue.empty():
                    queue.put(grid_copy)
                break
            grid_copy[row][col] = 0
            if stats is not None:
                stats['backtracks'] += 1

def display_progress(progress, stop_event):
    while not stop_event.is_set():
        clear_screen()
        print("Solving Sudoku...")
        if 'grid' in progress:
            print_grid(progress['grid'])
        else:
            print("Initializing...")
        time.sleep(0.5)
    clear_screen()
    if 'grid' in progress:
        print("Solved Sudoku:")
        print_grid(progress['grid'])
    else:
        print("No solution found.")

def main():
    grid = input_grid()
    clear_screen()
    print("Solving the sudoku...")
    time.sleep(1)
    start_time = time.time()

    manager = Manager()
    queue = manager.Queue()
    progress = manager.dict()
    progress['grid'] = [row[:] for row in grid]
    stats = manager.dict()
    stats['attempts'] = 0
    stats['backtracks'] = 0
    stop_event = multiprocessing.Event()

    # Preprocessing: Find cells with the least possibilities
    empty_cells = []
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                possible_numbers = get_possible_numbers(grid, i, j)
                empty_cells.append((i, j, possible_numbers))
    empty_cells.sort(key=lambda x: len(x[2]))
    if not empty_cells:
        print("Sudoku already solved!")
        return

    num_workers = min(9, multiprocessing.cpu_count(), len(empty_cells))
    processes = []

    # Start display thread
    display_thread = threading.Thread(target=display_progress, args=(progress, stop_event))
    display_thread.start()

    # Start worker processes
    for worker_id in range(num_workers):
        initial_cell = empty_cells[worker_id]
        p = multiprocessing.Process(target=worker, args=(
            grid, queue, progress, worker_id, stop_event, stats, initial_cell))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

    stop_event.set()
    display_thread.join()

    end_time = time.time()
    elapsed_time = end_time - start_time

    clear_screen()
    if not queue.empty():
        solved_grid = queue.get()
        print("Sudoku solved:")
        print_grid(solved_grid)
    else:
        print("No solution exists.")

    # Display statistics
    print("\nStatistics:")
    print(f"Time taken: {elapsed_time:.2f} seconds")
    print(f"Total attempts: {stats['attempts']}")
    print(f"Total backtracks: {stats['backtracks']}")
    if stats['attempts'] > 0:
        print(f"Backtrack ratio: {stats['backtracks']/stats['attempts']:.2f}")
    else:
        print("No attempts were made.")

if __name__ == "__main__":
    main()
